"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const events_1 = require("events");
const sharedApi_1 = require("../shared/sharedApi");
const lib_1 = require("../shared/lib");
const webWorkers_1 = require("./workerPlatform/webWorkers");
const workerThreads_1 = require("./workerPlatform/workerThreads");
const childProcess_1 = require("./workerPlatform/childProcess");
const fakeWorker_1 = require("./workerPlatform/fakeWorker");
class ThreadedClassManagerClass {
    constructor(internal) {
        this._internal = internal;
        this._internal.setMaxListeners(0);
    }
    /** Enable debug messages */
    set debug(v) {
        this._internal.debug = v;
    }
    get debug() {
        return this._internal.debug;
    }
    set dontHandleExit(v) {
        this._internal.dontHandleExit = v;
    }
    get dontHandleExit() {
        return this._internal.dontHandleExit;
    }
    /** Destroy a proxy class */
    destroy(proxy) {
        return this._internal.killProxy(proxy);
    }
    destroyAll() {
        return this._internal.killAllChildren();
    }
    /** Returns the number of threads */
    getThreadCount() {
        return this._internal.getChildrenCount();
    }
    /** Returns memory usage for all threads */
    getThreadsMemoryUsage() {
        return this._internal.getMemoryUsage();
    }
    onEvent(proxy, event, cb) {
        const onEvent = (child) => {
            let foundChild = Object.keys(child.instances).find((instanceId) => {
                const instance = child.instances[instanceId];
                return instance.proxy === proxy;
            });
            if (foundChild) {
                cb();
            }
        };
        this._internal.on(event, onEvent);
        return {
            stop: () => {
                this._internal.removeListener(event, onEvent);
            }
        };
    }
    /**
     * Restart the thread of the proxy instance
     * @param proxy
     * @param forceRestart If true, will kill the thread and restart it
     */
    restart(proxy, forceRestart) {
        return this._internal.restart(proxy, forceRestart);
    }
    /**
     * Returns a description of what threading mode the library will use in the current context.
     */
    getThreadMode() {
        if (lib_1.isBrowser()) {
            if (lib_1.browserSupportsWebWorkers()) {
                return ThreadMode.WEB_WORKER;
            }
            else {
                return ThreadMode.NOT_SUPPORTED;
            }
        }
        else {
            if (lib_1.nodeSupportsWorkerThreads()) {
                return ThreadMode.WORKER_THREADS;
            }
            else {
                return ThreadMode.CHILD_PROCESS;
            }
        }
    }
}
exports.ThreadedClassManagerClass = ThreadedClassManagerClass;
function childName(child) {
    return `Child_ ${Object.keys(child.instances).join(',')}`;
}
exports.childName = childName;
class ThreadedClassManagerClassInternal extends events_1.EventEmitter {
    constructor() {
        super(...arguments);
        /** Set to true if you want to handle the exiting of child process yourselt */
        this.dontHandleExit = false;
        this.isInitialized = false;
        this._threadId = 0;
        this._instanceId = 0;
        this._methodId = 0;
        this._children = {};
        this._pinging = true; // for testing only
        this.debug = false;
        /** Pseudo-unique id to identify the parent ThreadedClass (for debugging) */
        this.uniqueId = Date.now() % 10000;
    }
    findNextAvailableChild(config, pathToWorker) {
        this._init();
        let child = null;
        if (config.threadId) {
            child = this._children[config.threadId] || null;
        }
        else if (config.threadUsage) {
            child = this._findFreeChild(config.threadUsage);
        }
        if (!child) {
            // Create new child process:
            const newChild = {
                id: config.threadId || (`process_${this.uniqueId}_${this._threadId++}`),
                isNamed: !!config.threadId,
                pathToWorker: pathToWorker,
                process: this._createFork(config, pathToWorker),
                usage: config.threadUsage || 1,
                instances: {},
                methods: {},
                alive: true,
                isClosing: false,
                config,
                cmdId: 0,
                instanceMessageQueue: {},
                childMessageQueue: {},
                callbackId: 0,
                callbacks: {}
            };
            this._setupChildProcess(newChild);
            this._children[newChild.id] = newChild;
            child = newChild;
            if (this.debug)
                this.consoleLog(`New child: "${newChild.id}"`);
        }
        return child;
    }
    /**
     * Attach a proxy-instance to a child
     * @param child
     * @param proxy
     * @param onInstanceMessage
     */
    attachInstanceToChild(config, child, proxy, pathToModule, exportName, constructorArgs, onInstanceMessage) {
        const instance = {
            id: `instance_${this.uniqueId}_${this._instanceId++}` + (config.instanceName ? `_${config.instanceName}` : ''),
            child: child,
            proxy: proxy,
            usage: config.threadUsage,
            freezeLimit: config.freezeLimit,
            onMessageCallback: onInstanceMessage,
            pathToModule: pathToModule,
            exportName: exportName,
            constructorArgs: constructorArgs,
            initialized: false,
            config: config
        };
        child.instances[instance.id] = instance;
        if (this.debug)
            this.consoleLog(`Add instance "${instance.id}" to "${child.id}"`);
        return instance;
    }
    killProxy(proxy) {
        return new Promise((resolve, reject) => {
            let foundProxy = false;
            Object.keys(this._children).find((childId) => {
                const child = this._children[childId];
                const instanceId = Object.keys(child.instances).find((instanceId) => {
                    let instance = child.instances[instanceId];
                    return (instance.proxy === proxy);
                });
                if (instanceId) {
                    let instance = child.instances[instanceId];
                    foundProxy = true;
                    if (Object.keys(child.instances).length === 1) {
                        // if there is only one instance left, we can kill the child
                        this.killChild(childId)
                            .then(resolve)
                            .catch(reject);
                    }
                    else {
                        const cleanup = () => {
                            delete instance.child;
                            delete child.instances[instanceId];
                        };
                        this.sendMessageToInstance(instance, {
                            cmd: sharedApi_1.Message.To.Instance.CommandType.KILL
                        }, () => {
                            cleanup();
                            resolve();
                        });
                        setTimeout(() => {
                            cleanup();
                            reject('Timeout: Kill child instance');
                        }, 1000);
                        if (instance.usage) {
                            child.usage -= instance.usage;
                        }
                    }
                    return true;
                }
                return false;
            });
            if (!foundProxy) {
                reject('killProxy: Proxy not found');
            }
        });
    }
    sendMessageToInstance(instance, messageConstr, cb) {
        try {
            if (!instance.child)
                throw new Error(`Instance ${instance.id} has been detached from child process`);
            if (!instance.child.alive)
                throw new Error(`Child process of instance ${instance.id} has been closed`);
            if (instance.child.isClosing)
                throw new Error(`Child process of instance ${instance.id} is closing`);
            const message = Object.assign(Object.assign({}, messageConstr), {
                messageType: 'instance',
                cmdId: instance.child.cmdId++,
                instanceId: instance.id
            });
            if (message.cmd !== sharedApi_1.Message.To.Instance.CommandType.INIT &&
                !instance.initialized)
                throw Error(`Child instance ${instance.id} is not initialized`);
            if (cb)
                instance.child.instanceMessageQueue[message.cmdId + ''] = cb;
            try {
                instance.child.process.send(message);
            }
            catch (e) {
                delete instance.child.instanceMessageQueue[message.cmdId + ''];
                if ((e.toString() || '').match(/circular structure/)) { // TypeError: Converting circular structure to JSON
                    throw new Error(`Unsupported attribute (circular structure) in instance ${instance.id}: ` + e.toString());
                }
                else {
                    throw e;
                }
            }
        }
        catch (e) {
            if (cb)
                cb(instance, (e.stack || e).toString());
            else
                throw e;
        }
    }
    sendMessageToChild(child, messageConstr, cb) {
        try {
            if (!child.alive)
                throw new Error(`Child process ${child.id} has been closed`);
            if (child.isClosing)
                throw new Error(`Child process  ${child.id} is closing`);
            const message = Object.assign(Object.assign({}, messageConstr), {
                messageType: 'child',
                cmdId: child.cmdId++
            });
            if (cb)
                child.childMessageQueue[message.cmdId + ''] = cb;
            try {
                child.process.send(message);
            }
            catch (e) {
                delete child.childMessageQueue[message.cmdId + ''];
                if ((e.toString() || '').match(/circular structure/)) { // TypeError: Converting circular structure to JSON
                    throw new Error(`Unsupported attribute (circular structure) in child ${child.id}: ` + e.toString());
                }
                else {
                    throw e;
                }
            }
        }
        catch (e) {
            if (cb)
                cb((e.stack || e).toString());
            else
                throw e;
        }
    }
    getChildrenCount() {
        return Object.keys(this._children).length;
    }
    getMemoryUsage() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const memUsage = {};
            yield Promise.all(Object.keys(this._children).map((childId) => {
                return new Promise((resolve) => {
                    const child = this._children[childId];
                    this.sendMessageToChild(child, {
                        cmd: sharedApi_1.Message.To.Child.CommandType.GET_MEM_USAGE
                    }, (err, result0) => {
                        const result = result0 && sharedApi_1.decodeArguments(() => null, [result0], () => (() => Promise.resolve()))[0];
                        const o = Object.assign(Object.assign({}, (err ?
                            { error: err.toString() } :
                            result ?
                                result :
                                { error: 'unknown' })), { description: this.getChildDescriptor(child) });
                        memUsage[childId] = o;
                        resolve();
                    });
                });
            }));
            return memUsage;
        });
    }
    killAllChildren() {
        return Promise.all(Object.keys(this._children).map((id) => {
            const child = this._children[id];
            if (this.debug)
                this.consoleLog(`Killing child "${this.getChildDescriptor(child)}"`);
            return this.killChild(id);
        })).then(() => {
            return;
        });
    }
    restart(proxy, forceRestart) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let foundInstance;
            let foundChild;
            Object.keys(this._children).find((childId) => {
                const child = this._children[childId];
                const found = Object.keys(child.instances).find((instanceId) => {
                    const instance = child.instances[instanceId];
                    if (instance.proxy === proxy) {
                        foundInstance = instance;
                        return true;
                    }
                    return false;
                });
                if (found) {
                    foundChild = child;
                    return true;
                }
                return false;
            });
            if (!foundChild)
                throw Error(`Child of proxy not found`);
            if (!foundInstance)
                throw Error(`Instance of proxy not found`);
            yield this.restartChild(foundChild, [foundInstance], forceRestart);
        });
    }
    restartChild(child, onlyInstances, forceRestart) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (child.alive && forceRestart) {
                yield this.killChild(child, true);
            }
            if (!child.alive) {
                // clear old process:
                child.process.removeAllListeners();
                delete child.process;
                Object.keys(child.instances).forEach((instanceId) => {
                    const instance = child.instances[instanceId];
                    instance.initialized = false;
                });
                // start new process
                child.alive = true;
                child.isClosing = false;
                child.process = this._createFork(child.config, child.pathToWorker);
                this._setupChildProcess(child);
            }
            let p = new Promise((resolve, reject) => {
                const onInit = (child) => {
                    if (child === child) {
                        resolve();
                        this.removeListener('initialized', onInit);
                    }
                };
                this.on('initialized', onInit);
                setTimeout(() => {
                    reject('Timeout when trying to restart');
                    this.removeListener('initialized', onInit);
                }, 1000);
            });
            const promises = [];
            let instances = (onlyInstances ||
                Object.keys(child.instances).map((instanceId) => {
                    return child.instances[instanceId];
                }));
            instances.forEach((instance) => {
                promises.push(new Promise((resolve, reject) => {
                    this.sendInit(child, instance, instance.config, (_instance, err) => {
                        // no need to do anything, the proxy is already initialized from earlier
                        if (err) {
                            reject(err);
                        }
                        else {
                            resolve();
                        }
                        return true;
                    });
                }));
            });
            yield Promise.all(promises);
            yield p;
        });
    }
    sendInit(child, instance, config, cb) {
        let encodedArgs = sharedApi_1.encodeArguments(instance, instance.child.callbacks, instance.constructorArgs, !!config.disableMultithreading);
        let msg = {
            cmd: sharedApi_1.Message.To.Instance.CommandType.INIT,
            modulePath: instance.pathToModule,
            exportName: instance.exportName,
            args: encodedArgs,
            config: config,
            parentPid: process.pid
        };
        instance.initialized = true;
        exports.ThreadedClassManagerInternal.sendMessageToInstance(instance, msg, (instance, e, initProps) => {
            if (!cb ||
                cb(instance, e, initProps)) {
                this.emit('initialized', child);
            }
        });
    }
    startMonitoringChild(instance) {
        const pingTime = instance.freezeLimit || sharedApi_1.DEFAULT_CHILD_FREEZE_TIME;
        const monitorChild = () => {
            if (instance.child && instance.child.alive && this._pinging) {
                this._pingChild(instance)
                    .then(() => {
                    // ping successful
                    // ping again later:
                    setTimeout(() => {
                        monitorChild();
                    }, pingTime);
                })
                    .catch(() => {
                    // Ping failed
                    if (instance.child &&
                        instance.child.alive &&
                        !instance.child.isClosing) {
                        // this.consoleLog(`Ping failed for Child "${instance.child.id }" of instance "${instance.id}"`)
                        this._childHasCrashed(instance.child, `Child process ("${this.getChildDescriptor(instance.child)}") of instance ${instance.id} ping timeout`);
                    }
                });
            }
        };
        setTimeout(() => {
            monitorChild();
        }, pingTime);
    }
    doMethod(child, cb) {
        // Return a promise that will execute the callback cb
        // but also put the promise in child.methods, so that the promise can be aborted
        // in the case of a child crash
        const methodId = 'm' + this._methodId++;
        const p = new Promise((resolve, reject) => {
            child.methods[methodId] = { resolve, reject };
            cb(resolve, reject);
        })
            .then((result) => {
            delete child.methods[methodId];
            return result;
        })
            .catch((error) => {
            delete child.methods[methodId];
            throw error;
        });
        return p;
    }
    getChildDescriptor(child) {
        return `${child.id} (${Object.keys(child.instances).join(', ')})`;
    }
    /** Called before using internally */
    _init() {
        if (!this.isInitialized &&
            !this.dontHandleExit) {
            if (!lib_1.isBrowser()) { // in NodeJS
                // Close the child processes upon exit:
                process.stdin.resume(); // so the program will not close instantly
                // Read about Node signals here:
                // https://nodejs.org/api/process.html#process_signal_events
                const onSignal = (signal, message) => {
                    let msg = `Signal "${signal}" event`;
                    if (message)
                        msg += ', ' + message;
                    if (this.debug)
                        this.consoleLog(msg);
                    this.killAllChildren()
                        .catch(this.consoleError);
                    process.exit();
                };
                // Do something when app is closing:
                process.on('exit', (code) => onSignal('process.exit', `exit code: ${code}`));
                // catches ctrl+c event
                process.on('SIGINT', () => onSignal('SIGINT'));
                // Terminal windows closed
                process.on('SIGHUP', () => onSignal('SIGHUP'));
                process.on('SIGTERM', () => onSignal('SIGTERM'));
                // SIGKILL cannot have a listener attached
                // SIGSTOP cannot have a listener attached
                // catches "kill pid" (for example: nodemon restart)
                process.on('SIGUSR1', () => onSignal('SIGUSR1'));
                process.on('SIGUSR2', () => onSignal('SIGUSR2'));
                // catches uncaught exceptions
                process.on('uncaughtException', (message) => onSignal('uncaughtException', message.toString()));
            }
        }
        this.isInitialized = true;
    }
    _pingChild(instance) {
        return new Promise((resolve, reject) => {
            let msg = {
                cmd: sharedApi_1.Message.To.Instance.CommandType.PING
            };
            exports.ThreadedClassManagerInternal.sendMessageToInstance(instance, msg, (_instance, err) => {
                if (!err) {
                    resolve();
                }
                else {
                    this.consoleError(err);
                    reject(err);
                }
            });
            setTimeout(() => {
                reject(); // timeout
            }, instance.freezeLimit || sharedApi_1.DEFAULT_CHILD_FREEZE_TIME);
        });
    }
    _childHasCrashed(child, reason) {
        // Called whenever a fatal error with a child has been discovered
        this.rejectChildMethods(child, reason);
        if (!child.isClosing) {
            let shouldRestart = false;
            const restartInstances = [];
            Object.keys(child.instances).forEach((instanceId) => {
                const instance = child.instances[instanceId];
                if (instance.config.autoRestart) {
                    shouldRestart = true;
                    restartInstances.push(instance);
                }
            });
            if (shouldRestart) {
                this.restartChild(child, restartInstances, true)
                    .then(() => {
                    this.emit('restarted', child);
                })
                    .catch((err) => this.consoleError('Error when running restartChild()', err));
            }
            else {
                // No instance wants to be restarted, make sure the child is killed then:
                if (child.alive) {
                    this.killChild(child, true)
                        .catch((err) => this.consoleError('Error when running killChild()', err));
                }
            }
        }
    }
    _createFork(config, pathToWorker) {
        if (config.disableMultithreading) {
            return new fakeWorker_1.FakeProcess();
        }
        else {
            if (lib_1.isBrowser()) {
                return webWorkers_1.forkWebWorker(pathToWorker);
            }
            else {
                // in NodeJS
                if (lib_1.nodeSupportsWorkerThreads()) {
                    return workerThreads_1.forkWorkerThread(pathToWorker);
                }
                else {
                    return childProcess_1.forkChildProcess(pathToWorker);
                }
            }
        }
    }
    _setupChildProcess(child) {
        child.process.on('close', () => {
            if (child.alive) {
                child.alive = false;
                this.emit('thread_closed', child);
                this._childHasCrashed(child, `Child process "${childName(child)}" was closed`);
            }
        });
        child.process.on('error', (err) => {
            this.consoleError('Error from child ' + child.id, err);
        });
        child.process.on('message', (message) => {
            if (message.messageType === 'child') {
                try {
                    this._onMessageFromChild(child, message);
                }
                catch (e) {
                    this.consoleError(`Error in onMessageCallback in child ${child.id}`, message);
                    this.consoleError(e);
                    throw e;
                }
            }
            else if (message.messageType === 'instance') {
                const instance = child.instances[message.instanceId];
                if (instance) {
                    try {
                        instance.onMessageCallback(instance, message);
                    }
                    catch (e) {
                        this.consoleError(`Error in onMessageCallback in instance ${instance.id}`, message, instance);
                        this.consoleError(e);
                        throw e;
                    }
                }
                else {
                    this.consoleError(`Instance "${message.instanceId}" not found. Received message "${message.messageType}" from child "${child.id}", "${childName(child)}"`);
                }
            }
            else {
                this.consoleError(`Unknown messageType "${message['messageType']}"!`);
            }
        });
    }
    _onMessageFromChild(child, message) {
        if (message.cmd === sharedApi_1.Message.From.Child.CommandType.LOG) {
            console.log(child.id, ...message.log);
        }
        else if (message.cmd === sharedApi_1.Message.From.Child.CommandType.REPLY) {
            let msg = message;
            let cb = child.childMessageQueue[msg.replyTo + ''];
            if (!cb)
                return;
            if (msg.error) {
                cb(msg.error);
            }
            else {
                cb(null, msg.reply);
            }
            delete child.instanceMessageQueue[msg.replyTo + ''];
        }
        else if (message.cmd === sharedApi_1.Message.From.Child.CommandType.CALLBACK) {
            // Callback function is called by worker
            let msg = message;
            let callback = child.callbacks[msg.callbackId];
            if (callback) {
                try {
                    Promise.resolve(callback(...msg.args))
                        .then((result) => {
                        let encodedResult = sharedApi_1.encodeArguments({}, child.callbacks, [result], !!child.process.isFakeProcess);
                        this._sendReplyToChild(child, msg.cmdId, undefined, encodedResult[0]);
                    })
                        .catch((err) => {
                        this._replyErrorToChild(child, msg, err);
                    });
                }
                catch (err) {
                    this._replyErrorToChild(child, msg, err);
                }
            }
            else
                throw Error(`callback "${msg.callbackId}" not found in child ${child.id}`);
        }
    }
    _replyErrorToChild(child, messageToReplyTo, error) {
        this._sendReplyToChild(child, messageToReplyTo.cmdId, error);
    }
    _sendReplyToChild(child, replyTo, error, reply, cb) {
        let msg = {
            cmd: sharedApi_1.Message.To.Child.CommandType.REPLY,
            replyTo: replyTo,
            reply: reply,
            error: error ? (error.stack || error).toString() : error
        };
        this.sendMessageToChild(child, msg, cb);
    }
    _findFreeChild(threadUsage) {
        let id = Object.keys(this._children).find((id) => {
            const child = this._children[id];
            if (!child.isNamed &&
                child.usage + threadUsage <= 1) {
                return true;
            }
            return false;
        });
        if (id) {
            const child = this._children[id];
            child.usage += threadUsage;
            return child;
        }
        return null;
    }
    killChild(idOrChild, dontCleanUp) {
        return new Promise((resolve, reject) => {
            let child;
            if (typeof idOrChild === 'string') {
                const id = idOrChild;
                child = this._children[id];
                if (!child) {
                    reject(`killChild: Child ${id} not found`);
                    return;
                }
            }
            else {
                child = idOrChild;
            }
            if (child) {
                if (!child.alive) {
                    delete this._children[child.id];
                    resolve();
                }
                else {
                    child.process.once('close', () => {
                        if (!dontCleanUp) {
                            // Clean up:
                            Object.keys(child.instances).forEach(instanceId => {
                                const instance = child.instances[instanceId];
                                delete instance.child;
                                delete child.instances[instanceId];
                            });
                            delete this._children[child.id];
                        }
                        resolve();
                    });
                    setTimeout(() => {
                        delete this._children[child.id];
                        reject(`Timeout: Kill child process "${child.id}"`);
                    }, 1000);
                    if (!child.isClosing) {
                        child.isClosing = true;
                        child.process.kill();
                    }
                }
            }
        });
    }
    rejectChildMethods(child, reason) {
        Object.keys(child.methods).forEach((methodId) => {
            const method = child.methods[methodId];
            method.reject(Error('Method aborted due to: ' + reason));
        });
        child.methods = {};
    }
    /** trace to console.error */
    consoleError(...args) {
        console.error(`ThreadedClass Error (${this.uniqueId})`, ...args);
    }
    /** trace to console.log */
    consoleLog(...args) {
        console.log(`ThreadedClass (${this.uniqueId})`, ...args);
    }
}
exports.ThreadedClassManagerClassInternal = ThreadedClassManagerClassInternal;
var ThreadMode;
(function (ThreadMode) {
    /** Web-workers, in browser */
    ThreadMode["WEB_WORKER"] = "web_worker";
    /** Nothing, Web-workers not supported */
    ThreadMode["NOT_SUPPORTED"] = "not_supported";
    /** Worker threads */
    ThreadMode["WORKER_THREADS"] = "worker_threads";
    /** Child process */
    ThreadMode["CHILD_PROCESS"] = "child_process";
})(ThreadMode = exports.ThreadMode || (exports.ThreadMode = {}));
// Singleton:
exports.ThreadedClassManagerInternal = new ThreadedClassManagerClassInternal();
exports.ThreadedClassManager = new ThreadedClassManagerClass(exports.ThreadedClassManagerInternal);
//# sourceMappingURL=manager.js.map