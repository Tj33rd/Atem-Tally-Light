/// <reference types="node" />
import { EventEmitter } from 'events';
import { InitProps, CallbackFunction, Message, ArgDefinition } from '../shared/sharedApi';
import { ThreadedClassConfig, ThreadedClass, MemUsageReport } from '../api';
import { WorkerPlatformBase } from './workerPlatform/_base';
export declare class ThreadedClassManagerClass {
    private _internal;
    constructor(internal: ThreadedClassManagerClassInternal);
    /** Enable debug messages */
    debug: boolean;
    dontHandleExit: boolean;
    /** Destroy a proxy class */
    destroy(proxy: ThreadedClass<any>): Promise<void>;
    destroyAll(): Promise<void>;
    /** Returns the number of threads */
    getThreadCount(): number;
    /** Returns memory usage for all threads */
    getThreadsMemoryUsage(): Promise<{
        [childId: string]: MemUsageReport;
    }>;
    onEvent(proxy: ThreadedClass<any>, event: string, cb: Function): {
        stop: () => void;
    };
    /**
     * Restart the thread of the proxy instance
     * @param proxy
     * @param forceRestart If true, will kill the thread and restart it
     */
    restart(proxy: ThreadedClass<any>, forceRestart?: boolean): Promise<void>;
    /**
     * Returns a description of what threading mode the library will use in the current context.
     */
    getThreadMode(): ThreadMode;
}
/**
 * The Child represents a child process, in which the proxy-classes live and run
 */
export interface Child {
    readonly id: string;
    readonly isNamed: boolean;
    readonly pathToWorker: string;
    process: WorkerPlatformBase;
    usage: number;
    instances: {
        [id: string]: ChildInstance;
    };
    methods: {
        [id: string]: {
            resolve: (result: any) => void;
            reject: (error: any) => void;
        };
    };
    alive: boolean;
    isClosing: boolean;
    config: ThreadedClassConfig;
    cmdId: number;
    instanceMessageQueue: {
        [cmdId: string]: InstanceCallbackFunction;
    };
    childMessageQueue: {
        [cmdId: string]: CallbackFunction;
    };
    callbackId: number;
    callbacks: {
        [key: string]: Function;
    };
}
export declare function childName(child: Child): string;
export declare type InstanceCallbackFunction = (instance: ChildInstance, e: Error | string | null, encodedResult?: ArgDefinition) => void;
export declare type InstanceCallbackInitFunction = (instance: ChildInstance, e: Error | string | null, initProps?: InitProps) => boolean;
/**
 * The ChildInstance represents a proxy-instance of a class, running in a child process
 */
export interface ChildInstance {
    readonly id: string;
    readonly proxy: ThreadedClass<any>;
    readonly usage?: number;
    /** When to consider the process is frozen */
    readonly freezeLimit?: number;
    readonly onMessageCallback: (instance: ChildInstance, message: Message.From.Instance.Any) => void;
    readonly pathToModule: string;
    readonly exportName: string;
    readonly constructorArgs: any[];
    readonly config: ThreadedClassConfig;
    initialized: boolean;
    child: Child;
}
export declare class ThreadedClassManagerClassInternal extends EventEmitter {
    /** Set to true if you want to handle the exiting of child process yourselt */
    dontHandleExit: boolean;
    private isInitialized;
    private _threadId;
    private _instanceId;
    private _methodId;
    private _children;
    private _pinging;
    debug: boolean;
    /** Pseudo-unique id to identify the parent ThreadedClass (for debugging) */
    private uniqueId;
    findNextAvailableChild(config: ThreadedClassConfig, pathToWorker: string): Child;
    /**
     * Attach a proxy-instance to a child
     * @param child
     * @param proxy
     * @param onInstanceMessage
     */
    attachInstanceToChild(config: ThreadedClassConfig, child: Child, proxy: ThreadedClass<any>, pathToModule: string, exportName: string, constructorArgs: any[], onInstanceMessage: (instance: ChildInstance, message: Message.From.Instance.Any) => void): ChildInstance;
    killProxy(proxy: ThreadedClass<any>): Promise<void>;
    sendMessageToInstance(instance: ChildInstance, messageConstr: Message.To.Instance.AnyConstr, cb?: any | InstanceCallbackFunction | InstanceCallbackInitFunction): void;
    sendMessageToChild(child: Child, messageConstr: Message.To.Child.AnyConstr, cb?: CallbackFunction): void;
    getChildrenCount(): number;
    getMemoryUsage(): Promise<{
        [childId: string]: MemUsageReport;
    }>;
    killAllChildren(): Promise<void>;
    restart(proxy: ThreadedClass<any>, forceRestart?: boolean): Promise<void>;
    restartChild(child: Child, onlyInstances?: ChildInstance[], forceRestart?: boolean): Promise<void>;
    sendInit(child: Child, instance: ChildInstance, config: ThreadedClassConfig, cb?: InstanceCallbackInitFunction): void;
    startMonitoringChild(instance: ChildInstance): void;
    doMethod<T>(child: Child, cb: (resolve: (result: T | PromiseLike<T>) => void, reject: (error: any) => void) => void): Promise<T>;
    getChildDescriptor(child: Child): string;
    /** Called before using internally */
    private _init;
    private _pingChild;
    private _childHasCrashed;
    private _createFork;
    private _setupChildProcess;
    private _onMessageFromChild;
    private _replyErrorToChild;
    private _sendReplyToChild;
    private _findFreeChild;
    private killChild;
    private rejectChildMethods;
    /** trace to console.error */
    private consoleError;
    /** trace to console.log */
    private consoleLog;
}
export declare enum ThreadMode {
    /** Web-workers, in browser */
    WEB_WORKER = "web_worker",
    /** Nothing, Web-workers not supported */
    NOT_SUPPORTED = "not_supported",
    /** Worker threads */
    WORKER_THREADS = "worker_threads",
    /** Child process */
    CHILD_PROCESS = "child_process"
}
export declare const ThreadedClassManagerInternal: ThreadedClassManagerClassInternal;
export declare const ThreadedClassManager: ThreadedClassManagerClass;
