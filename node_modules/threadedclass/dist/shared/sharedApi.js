"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
// This file contains definitions for the API between the child and parent process.
exports.DEFAULT_CHILD_FREEZE_TIME = 1000; // how long to wait before considering a child to be unresponsive
var InitPropType;
(function (InitPropType) {
    InitPropType["FUNCTION"] = "function";
    InitPropType["VALUE"] = "value";
})(InitPropType = exports.InitPropType || (exports.InitPropType = {}));
// Messages to/from child instances ------------------------------------------------
/** Definitions of all messages between the child and parent */
var Message;
(function (Message) {
    /** Defines messages from the child ot the parent process */
    let To;
    (function (To) {
        let Instance;
        (function (Instance) {
            let CommandType;
            (function (CommandType) {
                CommandType["INIT"] = "init";
                CommandType["PING"] = "ping";
                CommandType["FUNCTION"] = "fcn";
                CommandType["REPLY"] = "reply";
                CommandType["SET"] = "set";
                CommandType["KILL"] = "kill";
                CommandType["CALLBACK"] = "callback";
            })(CommandType = Instance.CommandType || (Instance.CommandType = {}));
        })(Instance = To.Instance || (To.Instance = {}));
        let Child;
        (function (Child) {
            let CommandType;
            (function (CommandType) {
                CommandType["GET_MEM_USAGE"] = "get_mem_usage";
                CommandType["REPLY"] = "reply";
            })(CommandType = Child.CommandType || (Child.CommandType = {}));
        })(Child = To.Child || (To.Child = {}));
    })(To = Message.To || (Message.To = {}));
    /** Defines messages from the parent process to the child */
    let From;
    (function (From) {
        let Instance;
        (function (Instance) {
            let CommandType;
            (function (CommandType) {
                CommandType["CALLBACK"] = "callback";
                CommandType["REPLY"] = "reply";
            })(CommandType = Instance.CommandType || (Instance.CommandType = {}));
        })(Instance = From.Instance || (From.Instance = {}));
        let Child;
        (function (Child) {
            let CommandType;
            (function (CommandType) {
                CommandType["LOG"] = "log";
                CommandType["REPLY"] = "reply";
                CommandType["CALLBACK"] = "callback";
            })(CommandType = Child.CommandType || (Child.CommandType = {}));
        })(Child = From.Child || (From.Child = {}));
    })(From = Message.From || (Message.From = {}));
})(Message = exports.Message || (exports.Message = {}));
var ArgumentType;
(function (ArgumentType) {
    ArgumentType["STRING"] = "string";
    ArgumentType["NUMBER"] = "number";
    ArgumentType["UNDEFINED"] = "undefined";
    ArgumentType["NULL"] = "null";
    ArgumentType["OBJECT"] = "object";
    ArgumentType["FUNCTION"] = "function";
    ArgumentType["BUFFER"] = "buffer";
    ArgumentType["OTHER"] = "other";
})(ArgumentType || (ArgumentType = {}));
let argumentsCallbackId = 0;
function encodeArguments(instance, callbacks, args, disabledMultithreading) {
    try {
        return args.map((arg, i) => {
            try {
                if (typeof arg === 'object' && arg === instance) {
                    return { type: ArgumentType.OBJECT, value: 'self' };
                }
                if (disabledMultithreading) {
                    // In single-threaded mode, we can send the arguments directly, without any conversion:
                    if (arg instanceof Buffer)
                        return { type: ArgumentType.BUFFER, original: arg, value: null };
                    if (typeof arg === 'object')
                        return { type: ArgumentType.OBJECT, original: arg, value: null };
                }
                if (arg instanceof Buffer)
                    return { type: ArgumentType.BUFFER, value: arg.toString('hex') };
                if (typeof arg === 'string')
                    return { type: ArgumentType.STRING, value: arg };
                if (typeof arg === 'number')
                    return { type: ArgumentType.NUMBER, value: arg };
                if (typeof arg === 'function') {
                    const callbackId = argumentsCallbackId++;
                    callbacks[callbackId + ''] = arg;
                    return { type: ArgumentType.FUNCTION, value: callbackId + '' };
                }
                if (arg === undefined)
                    return { type: ArgumentType.UNDEFINED, value: arg };
                if (arg === null)
                    return { type: ArgumentType.NULL, value: arg };
                if (typeof arg === 'object')
                    return { type: ArgumentType.OBJECT, value: arg };
                return { type: ArgumentType.OTHER, value: arg };
            }
            catch (e) {
                if (e.stack)
                    e.stack += '\nIn encodeArguments, argument ' + i;
                throw e;
            }
        });
    }
    catch (e) {
        if (e.stack)
            e.stack += '\nThreadedClass, unsupported attribute';
        throw e;
    }
}
exports.encodeArguments = encodeArguments;
function decodeArguments(instance, args, getCallback) {
    // Go through arguments and de-serialize them
    return args.map((a) => {
        if (a.original !== undefined)
            return a.original;
        if (a.type === ArgumentType.STRING)
            return a.value;
        if (a.type === ArgumentType.NUMBER)
            return a.value;
        if (a.type === ArgumentType.BUFFER)
            return Buffer.from(a.value, 'hex');
        if (a.type === ArgumentType.UNDEFINED)
            return a.value;
        if (a.type === ArgumentType.NULL)
            return a.value;
        if (a.type === ArgumentType.FUNCTION) {
            return getCallback(a);
        }
        if (a.type === ArgumentType.OBJECT) {
            if (a.value === 'self') {
                return instance();
            }
            else {
                return a.value;
            }
        }
        return a.value;
    });
}
exports.decodeArguments = decodeArguments;
//# sourceMappingURL=sharedApi.js.map